import pygame
import time
import math

# 파이게임 초기화
pygame.init()

# 화면 크기 설정
screen_width, screen_height = 800, 600
screen = pygame.display.set_mode((screen_width, screen_height))
pygame.display.set_caption('Traffic Simulation')

# 색상 정의
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
YELLOW = (255, 255, 0)
BLUE = (0, 0, 255)

# 차량 클래스
class Vehicle(pygame.sprite.Sprite):
    def __init__(self, x, y, speed, size_x=20, size_y=10):
        super().__init__()
        self.original_image = pygame.Surface([size_x, size_y])
        self.original_image.fill(BLUE)
        self.image = self.original_image.copy()
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.speed = speed
        self.size_x = size_x
        self.size_y = size_y
        self.path = []
        self.current_index = 0
        self.moving = True  # Vehicle starts by moving
        self.angle = 0

    def update(self, traffic_lights, vehicles, intersection_rect):
        if self.path and self.current_index < len(self.path):
            next_pos = self.path[self.current_index]
            next_rect = self.rect.copy()
            next_rect.x, next_rect.y = next_pos[0], next_pos[1]

            # Check for potential collisions with other vehicles
            self.moving = True
            for vehicle in vehicles:
                if vehicle != self and next_rect.colliderect(vehicle.rect.inflate(40, 40)):
                    self.moving = False
                    break

            # Check traffic lights at the intersection
            if self.moving and intersection_rect.colliderect(next_rect):
                for light in traffic_lights:
                    if light.rect.colliderect(intersection_rect):
                        current_time = time.time()
                        time_since_last_switch = current_time - light.last_switch
                        if light.state == 'red':
                            self.moving = False
                            break
                        elif light.state == 'yellow' and light.red_time - time_since_last_switch <= 1:
                            self.moving = False
                            break

            if self.moving:
                dx, dy = next_pos[0] - self.rect.x, next_pos[1] - self.rect.y
                distance = math.hypot(dx, dy)
                if distance > 0:
                    self.angle = math.degrees(math.atan2(-dy, dx))
                    self.image = pygame.transform.rotate(self.original_image, self.angle)
                    self.rect = self.image.get_rect(center=self.rect.center)
                if distance < self.speed:
                    self.rect.x, self.rect.y = next_pos
                    self.current_index += 1
                else:
                    self.rect.x += self.speed * dx / distance
                    self.rect.y += self.speed * dy / distance
                
                # Calculate angle only if there is a significant change in direction
                

    def set_path(self, path):
        self.path = path
        self.current_index = 0

# 신호등 클래스
class TrafficLight(pygame.sprite.Sprite):
    def __init__(self, x, y, green_time, yellow_time, red_time):
        super().__init__()
        self.image = pygame.Surface([20, 20])
        self.image.fill(RED)
        self.rect = self.image.get_rect()
        self.rect.center = (x, y)
        self.green_time = green_time
        self.yellow_time = yellow_time
        self.red_time = red_time
        self.state = 'red'
        self.last_switch = time.time()

    def update(self):
        current_time = time.time()
        time_since_last_switch = current_time - self.last_switch

        if self.state == 'red' and time_since_last_switch > self.red_time:
            self.state = 'green'
            self.image.fill(GREEN)
            self.last_switch = current_time
        elif self.state == 'green' and time_since_last_switch > self.green_time:
            self.state = 'yellow'
            self.image.fill(YELLOW)
            self.last_switch = current_time
        elif self.state == 'yellow' and time_since_last_switch > self.yellow_time:
            self.state = 'red'
            self.image.fill(RED)
            self.last_switch = current_time

# 도로 클래스
class Road:
    def __init__(self, start_pos, end_pos, width, color=BLACK):
        self.start_pos = start_pos
        self.end_pos = end_pos
        self.width = width
        self.color = color

    def draw(self, screen):
        pygame.draw.line(screen, self.color, self.start_pos, self.end_pos, self.width)

    def is_on_road(self, position):
        # Check if the position is within the road boundaries
        if self.start_pos[0] == self.end_pos[0]:  # Vertical road
            if self.start_pos[1] <= position[1] <= self.end_pos[1] or self.end_pos[1] <= position[1] <= self.start_pos[1]:
                if abs(position[0] - self.start_pos[0]) <= self.width // 2:
                    return True
        elif self.start_pos[1] == self.end_pos[1]:  # Horizontal road
            if self.start_pos[0] <= position[0] <= self.end_pos[0] or self.end_pos[0] <= position[0] <= self.start_pos[0]:
                if abs(position[1] - self.start_pos[1]) <= self.width // 2:
                    return True
        return False

# 차선 구분 클래스
class LaneMarker:
    def __init__(self, start_pos, end_pos, color=WHITE, style='dashed'):
        self.start_pos = start_pos
        self.end_pos = end_pos
        self.color = color
        self.style = style

    def draw(self, screen):
        if self.style == 'dashed':
            self.draw_dashed_line(screen)

    def draw_dashed_line(self, screen):
        length = math.hypot(self.end_pos[0] - self.start_pos[0], self.end_pos[1] - self.start_pos[1])
        dash_length = 10
        dash_space = 5
        num_dashes = int(length // (dash_length + dash_space))

        for i in range(num_dashes):
            start_x = self.start_pos[0] + (self.end_pos[0] - self.start_pos[0]) * i / num_dashes
            start_y = self.start_pos[1] + (self.end_pos[1] - self.start_pos[1]) * i / num_dashes
            end_x = self.start_pos[0] + (self.end_pos[0] - self.start_pos[0]) * (i + 0.5) / num_dashes
            end_y = self.start_pos[1] + (self.end_pos[1] - self.start_pos[1]) * (i + 0.5) / num_dashes
            pygame.draw.line(screen, self.color, (start_x, start_y), (end_x, end_y), 2)

# 경로 설정 함수
def calculate_path(start_pos, end_pos, roads):
    path = [start_pos]
    current_pos = start_pos

    while current_pos != end_pos:
        if current_pos[0] != end_pos[0]:  # 수평 이동
            step = 1 if current_pos[0] < end_pos[0] else -1
            while current_pos[0] != end_pos[0]:
                current_pos = (current_pos[0] + step, current_pos[1])
                if is_road(current_pos, roads):
                    path.append(current_pos)
                else:
                    break
        if current_pos[1] != end_pos[1]:  # 수직 이동
            step = 1 if current_pos[1] < end_pos[1] else -1
            while current_pos[1] != end_pos[1]:
                current_pos = (current_pos[0], current_pos[1] + step)
                if is_road(current_pos, roads):
                    path.append(current_pos)
                else:
                    break
    return path

def is_road(position, roads):
    for road in roads:
        if road.is_on_road(position):
            return True
    return False

# 스프라이트 그룹 생성
all_sprites = pygame.sprite.Group()
traffic_lights = pygame.sprite.Group()
vehicles = pygame.sprite.Group()

# 신호등 생성
traffic_light1 = TrafficLight(400, 300, green_time=5, yellow_time=1, red_time=5)
traffic_lights.add(traffic_light1)
all_sprites.add(traffic_light1)

# 교차로 영역 정의
intersection_rect = pygame.Rect(380, 280, 40, 40)

# 차량 생성
vehicle1 = Vehicle(100, 310, speed=2)
all_sprites.add(vehicle1)
vehicles.add(vehicle1)

vehicle2 = Vehicle(200, 310, speed=2)
all_sprites.add(vehicle2)
vehicles.add(vehicle2)

# 도로 및 차선 구분선 생성
roads = [
    Road((0, 300), (800, 300), 40),
    Road((400, 0), (400, 600), 40)
]

lane_markers = [
    LaneMarker((0, 300), (800, 300), WHITE, 'dashed'),
    LaneMarker((400, 0), (400, 600), WHITE, 'dashed')
]

# 경로 설정
start_pos = (100, 310)
end_pos = (400, 110)
if is_road(end_pos, roads):
    path = calculate_path(start_pos, end_pos, roads)
    print(f"Path for vehicle1: {path}")  # Debugging: Print the path
    if path:
        vehicle1.set_path(path)
    else:
        print("No path found for vehicle1")
else:
    print(f"End position {end_pos} is not on the road for vehicle1")

# 경로 설정
start_pos2 = (200, 310)
end_pos2 = (400, 110)
if is_road(end_pos2, roads):
    path2 = calculate_path(start_pos2, end_pos2, roads)
    print(f"Path for vehicle2: {path2}")  # Debugging: Print the path
    if path2:
        vehicle2.set_path(path2)
    else:
        print("No path found for vehicle2")
else:
    print(f"End position {end_pos2} is not on the road for vehicle2")

# 메인 루프
running = True
clock = pygame.time.Clock()

while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    # 업데이트
    traffic_lights.update()
    for vehicle in vehicles:
        vehicle.update(traffic_lights, vehicles, intersection_rect)

    # 화면 채우기
    screen.fill(WHITE)

    # 도로 그리기
    for road in roads:
        road.draw(screen)

    # 차선 구분선 그리기
    for marker in lane_markers:
        marker.draw(screen)

    # 스프라이트 그리기
    all_sprites.draw(screen)

    # 화면 업데이트
    pygame.display.flip()

    # 초당 60 프레임으로 설정
    clock.tick(60)

pygame.quit()
